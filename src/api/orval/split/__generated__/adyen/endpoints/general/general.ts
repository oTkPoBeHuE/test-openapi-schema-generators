/**
 * Generated by orval v7.3.0 üç∫
 * Do not edit manually.
 * Fund API
 * This API is used for the classic integration. If you are just starting your implementation, refer to our [new integration guide](https://docs.adyen.com/marketplaces-and-platforms) instead.

The Fund API provides endpoints for managing the funds in the accounts on your platform. These management operations include, for example, the transfer of funds from one account to another, the payout of funds to an account holder, and the retrieval of balances in an account.

For more information, refer to our [documentation](https://docs.adyen.com/marketplaces-and-platforms/classic/).
## Authentication
Your Adyen contact will provide your API credential and an API key. To connect to the API, add an `X-API-Key` header with the API key as the value, for example:

 ```
curl
-H "Content-Type: application/json" \
-H "X-API-Key: YOUR_API_KEY" \
...
```

Alternatively, you can use the username and password to connect to the API using basic authentication. For example:

```
curl
-U "ws@MarketPlace.YOUR_PLATFORM_ACCOUNT":"YOUR_WS_PASSWORD" \
-H "Content-Type: application/json" \
...
```
When going live, you need to generate new web service user credentials to access the [live endpoints](https://docs.adyen.com/development-resources/live-endpoints).

## Versioning
The Fund API supports [versioning](https://docs.adyen.com/development-resources/versioning) using a version suffix in the endpoint URL. This suffix has the following format: "vXX", where XX is the version number.

For example:
```
https://cal-test.adyen.com/cal/services/Fund/v6/accountHolderBalance
```
 * OpenAPI spec version: 6
 */
import {
  useMutation
} from '@tanstack/react-query'
import type {
  MutationFunction,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query'
import * as axios from 'axios';
import type {
  AxiosError,
  AxiosRequestConfig,
  AxiosResponse
} from 'axios'
import type {
  AccountHolderBalanceRequest
} from '../../model/accountHolderBalanceRequest'
import type {
  AccountHolderBalanceResponse
} from '../../model/accountHolderBalanceResponse'
import type {
  AccountHolderTransactionListRequest
} from '../../model/accountHolderTransactionListRequest'
import type {
  AccountHolderTransactionListResponse
} from '../../model/accountHolderTransactionListResponse'
import type {
  DebitAccountHolderRequest
} from '../../model/debitAccountHolderRequest'
import type {
  DebitAccountHolderResponse
} from '../../model/debitAccountHolderResponse'
import type {
  PayoutAccountHolderRequest
} from '../../model/payoutAccountHolderRequest'
import type {
  PayoutAccountHolderResponse
} from '../../model/payoutAccountHolderResponse'
import type {
  RefundFundsTransferRequest
} from '../../model/refundFundsTransferRequest'
import type {
  RefundFundsTransferResponse
} from '../../model/refundFundsTransferResponse'
import type {
  RefundNotPaidOutTransfersRequest
} from '../../model/refundNotPaidOutTransfersRequest'
import type {
  RefundNotPaidOutTransfersResponse
} from '../../model/refundNotPaidOutTransfersResponse'
import type {
  ServiceError
} from '../../model/serviceError'
import type {
  SetupBeneficiaryRequest
} from '../../model/setupBeneficiaryRequest'
import type {
  SetupBeneficiaryResponse
} from '../../model/setupBeneficiaryResponse'
import type {
  TransferFundsRequest
} from '../../model/transferFundsRequest'
import type {
  TransferFundsResponse
} from '../../model/transferFundsResponse'



/**
 * Returns the account balances of an account holder. An account's balances are organized according by currencies. This mean that an account may have multiple balances: one for each currency.
 * @summary Get the balances of an account holder
 */
export const postAccountHolderBalance = (
    accountHolderBalanceRequest: AccountHolderBalanceRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountHolderBalanceResponse>> => {
    
    return axios.default.post(
      `/accountHolderBalance`,
      accountHolderBalanceRequest,options
    );
  }



export const getPostAccountHolderBalanceMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderBalance>>, TError,{data: AccountHolderBalanceRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderBalance>>, TError,{data: AccountHolderBalanceRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAccountHolderBalance>>, {data: AccountHolderBalanceRequest}> = (props) => {
          const {data} = props ?? {};

          return  postAccountHolderBalance(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAccountHolderBalanceMutationResult = NonNullable<Awaited<ReturnType<typeof postAccountHolderBalance>>>
    export type PostAccountHolderBalanceMutationBody = AccountHolderBalanceRequest
    export type PostAccountHolderBalanceMutationError = AxiosError<ServiceError>

    /**
 * @summary Get the balances of an account holder
 */
export const usePostAccountHolderBalance = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderBalance>>, TError,{data: AccountHolderBalanceRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAccountHolderBalance>>,
        TError,
        {data: AccountHolderBalanceRequest},
        TContext
      > => {

      const mutationOptions = getPostAccountHolderBalanceMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Returns a list of transactions for an account holder's accounts. You can specify the accounts and transaction statuses to be included on the list. The call returns a maximum of 50 transactions for each account. To retrieve all transactions, you must make another call with the 'page' value incremented. Transactions are listed in chronological order, with the most recent transaction first.
 * @summary Get a list of transactions
 */
export const postAccountHolderTransactionList = (
    accountHolderTransactionListRequest: AccountHolderTransactionListRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<AccountHolderTransactionListResponse>> => {
    
    return axios.default.post(
      `/accountHolderTransactionList`,
      accountHolderTransactionListRequest,options
    );
  }



export const getPostAccountHolderTransactionListMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderTransactionList>>, TError,{data: AccountHolderTransactionListRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderTransactionList>>, TError,{data: AccountHolderTransactionListRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postAccountHolderTransactionList>>, {data: AccountHolderTransactionListRequest}> = (props) => {
          const {data} = props ?? {};

          return  postAccountHolderTransactionList(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostAccountHolderTransactionListMutationResult = NonNullable<Awaited<ReturnType<typeof postAccountHolderTransactionList>>>
    export type PostAccountHolderTransactionListMutationBody = AccountHolderTransactionListRequest
    export type PostAccountHolderTransactionListMutationError = AxiosError<ServiceError>

    /**
 * @summary Get a list of transactions
 */
export const usePostAccountHolderTransactionList = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postAccountHolderTransactionList>>, TError,{data: AccountHolderTransactionListRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postAccountHolderTransactionList>>,
        TError,
        {data: AccountHolderTransactionListRequest},
        TContext
      > => {

      const mutationOptions = getPostAccountHolderTransactionListMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Sends a direct debit request to an account holder's bank account. If the direct debit is successful, the funds are settled in the accounts specified in the split instructions. Adyen sends the result of the direct debit in a [`DIRECT_DEBIT_INITIATED`](https://docs.adyen.com/api-explorer/#/NotificationService/latest/post/DIRECT_DEBIT_INITIATED) notification webhook.

 To learn more about direct debits, see [Top up accounts](https://docs.adyen.com/marketplaces-and-platforms/classic/top-up-accounts).
 * @summary Send a direct debit request
 */
export const postDebitAccountHolder = (
    debitAccountHolderRequest: DebitAccountHolderRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<DebitAccountHolderResponse>> => {
    
    return axios.default.post(
      `/debitAccountHolder`,
      debitAccountHolderRequest,options
    );
  }



export const getPostDebitAccountHolderMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDebitAccountHolder>>, TError,{data: DebitAccountHolderRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postDebitAccountHolder>>, TError,{data: DebitAccountHolderRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postDebitAccountHolder>>, {data: DebitAccountHolderRequest}> = (props) => {
          const {data} = props ?? {};

          return  postDebitAccountHolder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostDebitAccountHolderMutationResult = NonNullable<Awaited<ReturnType<typeof postDebitAccountHolder>>>
    export type PostDebitAccountHolderMutationBody = DebitAccountHolderRequest
    export type PostDebitAccountHolderMutationError = AxiosError<ServiceError>

    /**
 * @summary Send a direct debit request
 */
export const usePostDebitAccountHolder = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postDebitAccountHolder>>, TError,{data: DebitAccountHolderRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postDebitAccountHolder>>,
        TError,
        {data: DebitAccountHolderRequest},
        TContext
      > => {

      const mutationOptions = getPostDebitAccountHolderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Pays out a specified amount from an account to the bank account of account holder.
 * @summary Pay out from an account to the account holder
 */
export const postPayoutAccountHolder = (
    payoutAccountHolderRequest: PayoutAccountHolderRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<PayoutAccountHolderResponse>> => {
    
    return axios.default.post(
      `/payoutAccountHolder`,
      payoutAccountHolderRequest,options
    );
  }



export const getPostPayoutAccountHolderMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPayoutAccountHolder>>, TError,{data: PayoutAccountHolderRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postPayoutAccountHolder>>, TError,{data: PayoutAccountHolderRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postPayoutAccountHolder>>, {data: PayoutAccountHolderRequest}> = (props) => {
          const {data} = props ?? {};

          return  postPayoutAccountHolder(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostPayoutAccountHolderMutationResult = NonNullable<Awaited<ReturnType<typeof postPayoutAccountHolder>>>
    export type PostPayoutAccountHolderMutationBody = PayoutAccountHolderRequest
    export type PostPayoutAccountHolderMutationError = AxiosError<ServiceError>

    /**
 * @summary Pay out from an account to the account holder
 */
export const usePostPayoutAccountHolder = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postPayoutAccountHolder>>, TError,{data: PayoutAccountHolderRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postPayoutAccountHolder>>,
        TError,
        {data: PayoutAccountHolderRequest},
        TContext
      > => {

      const mutationOptions = getPostPayoutAccountHolderMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Refunds funds transferred from one account to another. Both accounts must be in the same platform, but can have different account holders. 
 * @summary Refund a funds transfer
 */
export const postRefundFundsTransfer = (
    refundFundsTransferRequest: RefundFundsTransferRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RefundFundsTransferResponse>> => {
    
    return axios.default.post(
      `/refundFundsTransfer`,
      refundFundsTransferRequest,options
    );
  }



export const getPostRefundFundsTransferMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefundFundsTransfer>>, TError,{data: RefundFundsTransferRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRefundFundsTransfer>>, TError,{data: RefundFundsTransferRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRefundFundsTransfer>>, {data: RefundFundsTransferRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRefundFundsTransfer(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRefundFundsTransferMutationResult = NonNullable<Awaited<ReturnType<typeof postRefundFundsTransfer>>>
    export type PostRefundFundsTransferMutationBody = RefundFundsTransferRequest
    export type PostRefundFundsTransferMutationError = AxiosError<ServiceError>

    /**
 * @summary Refund a funds transfer
 */
export const usePostRefundFundsTransfer = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefundFundsTransfer>>, TError,{data: RefundFundsTransferRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRefundFundsTransfer>>,
        TError,
        {data: RefundFundsTransferRequest},
        TContext
      > => {

      const mutationOptions = getPostRefundFundsTransferMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Refunds all the transactions of an account that have taken place since the most recent payout. This request is on a account basis (as opposed to a payment basis), so only the portion of the payment that was made to the specified account is refunded. The commissions, fees, and payments to other accounts remain in the accounts to which they were sent as designated by the original payment's split details.
 * @summary Refund all transactions of an account since the most recent payout
 */
export const postRefundNotPaidOutTransfers = (
    refundNotPaidOutTransfersRequest: RefundNotPaidOutTransfersRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<RefundNotPaidOutTransfersResponse>> => {
    
    return axios.default.post(
      `/refundNotPaidOutTransfers`,
      refundNotPaidOutTransfersRequest,options
    );
  }



export const getPostRefundNotPaidOutTransfersMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>, TError,{data: RefundNotPaidOutTransfersRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>, TError,{data: RefundNotPaidOutTransfersRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>, {data: RefundNotPaidOutTransfersRequest}> = (props) => {
          const {data} = props ?? {};

          return  postRefundNotPaidOutTransfers(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostRefundNotPaidOutTransfersMutationResult = NonNullable<Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>>
    export type PostRefundNotPaidOutTransfersMutationBody = RefundNotPaidOutTransfersRequest
    export type PostRefundNotPaidOutTransfersMutationError = AxiosError<ServiceError>

    /**
 * @summary Refund all transactions of an account since the most recent payout
 */
export const usePostRefundNotPaidOutTransfers = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>, TError,{data: RefundNotPaidOutTransfersRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postRefundNotPaidOutTransfers>>,
        TError,
        {data: RefundNotPaidOutTransfersRequest},
        TContext
      > => {

      const mutationOptions = getPostRefundNotPaidOutTransfersMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Defines a benefactor and a beneficiary relationship between two accounts. At the time of benefactor/beneficiary setup, the funds in the benefactor account are transferred to the beneficiary account, and any further payments to the benefactor account are automatically sent to the beneficiary account. A series of benefactor/beneficiaries may not exceed four beneficiaries and may not have a cycle in it.
 * @summary Designate a beneficiary account and transfer the benefactor's current balance
 */
export const postSetupBeneficiary = (
    setupBeneficiaryRequest: SetupBeneficiaryRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<SetupBeneficiaryResponse>> => {
    
    return axios.default.post(
      `/setupBeneficiary`,
      setupBeneficiaryRequest,options
    );
  }



export const getPostSetupBeneficiaryMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSetupBeneficiary>>, TError,{data: SetupBeneficiaryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postSetupBeneficiary>>, TError,{data: SetupBeneficiaryRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postSetupBeneficiary>>, {data: SetupBeneficiaryRequest}> = (props) => {
          const {data} = props ?? {};

          return  postSetupBeneficiary(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostSetupBeneficiaryMutationResult = NonNullable<Awaited<ReturnType<typeof postSetupBeneficiary>>>
    export type PostSetupBeneficiaryMutationBody = SetupBeneficiaryRequest
    export type PostSetupBeneficiaryMutationError = AxiosError<ServiceError>

    /**
 * @summary Designate a beneficiary account and transfer the benefactor's current balance
 */
export const usePostSetupBeneficiary = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postSetupBeneficiary>>, TError,{data: SetupBeneficiaryRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postSetupBeneficiary>>,
        TError,
        {data: SetupBeneficiaryRequest},
        TContext
      > => {

      const mutationOptions = getPostSetupBeneficiaryMutationOptions(options);

      return useMutation(mutationOptions);
    }
    /**
 * Transfers funds from one account to another account. Both accounts must be in the same platform, but can have different account holders. The transfer must include a transfer code, which should be determined by the platform, in compliance with local regulations.
 * @summary Transfer funds between platform accounts
 */
export const postTransferFunds = (
    transferFundsRequest: TransferFundsRequest, options?: AxiosRequestConfig
 ): Promise<AxiosResponse<TransferFundsResponse>> => {
    
    return axios.default.post(
      `/transferFunds`,
      transferFundsRequest,options
    );
  }



export const getPostTransferFundsMutationOptions = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransferFunds>>, TError,{data: TransferFundsRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationOptions<Awaited<ReturnType<typeof postTransferFunds>>, TError,{data: TransferFundsRequest}, TContext> => {
const {mutation: mutationOptions, axios: axiosOptions} = options ?? {};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof postTransferFunds>>, {data: TransferFundsRequest}> = (props) => {
          const {data} = props ?? {};

          return  postTransferFunds(data,axiosOptions)
        }

        


  return  { mutationFn, ...mutationOptions }}

    export type PostTransferFundsMutationResult = NonNullable<Awaited<ReturnType<typeof postTransferFunds>>>
    export type PostTransferFundsMutationBody = TransferFundsRequest
    export type PostTransferFundsMutationError = AxiosError<ServiceError>

    /**
 * @summary Transfer funds between platform accounts
 */
export const usePostTransferFunds = <TError = AxiosError<ServiceError>,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof postTransferFunds>>, TError,{data: TransferFundsRequest}, TContext>, axios?: AxiosRequestConfig}
): UseMutationResult<
        Awaited<ReturnType<typeof postTransferFunds>>,
        TError,
        {data: TransferFundsRequest},
        TContext
      > => {

      const mutationOptions = getPostTransferFundsMutationOptions(options);

      return useMutation(mutationOptions);
    }
    